

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Dask on HPC - Starting Clusters, Monitoring, and Debugging &#8212; Dask Tutorial</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/05-dask-hpc';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dask Chunking - Best Practices" href="06-dask-chunking.html" />
    <link rel="prev" title="Dask Schedulers" href="04-dask-cluster.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../README.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/NCAR_CISL_logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/NCAR_CISL_logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../README.html">
                    NCAR Dask Tutorial
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introductions to Dask</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="00-dask-overview.html">Dask Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="01-dask-array.html">Dask Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-dask-dataframe.html">Dask DataFrame</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Dask and Xarray</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="03-dask-xarray.html">Parallelizing Xarray with Dask</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Dask on HPC</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="04-dask-cluster.html">Dask Schedulers</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Dask on HPC - Starting Clusters, Monitoring, and Debugging</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Dask Best Practices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="06-dask-chunking.html">Dask Chunking - Best Practices</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/NCAR/dask-tutorial/main?urlpath=lab/tree/notebooks/05-dask-hpc.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onBinder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li><a href="https://jupyterhub.hpc.ucar.edu/stable/hub/user-redirect/git-pull?repo=https%3A//github.com/NCAR/dask-tutorial&urlpath=lab/tree/dask-tutorial/notebooks/05-dask-hpc.ipynb&branch=main" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch onJupyterHub"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="btn__text-container">JupyterHub</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/NCAR/dask-tutorial" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/NCAR/dask-tutorial/edit/main/notebooks/05-dask-hpc.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/NCAR/dask-tutorial/issues/new?title=Issue%20on%20page%20%2Fnotebooks/05-dask-hpc.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/notebooks/05-dask-hpc.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Dask on HPC - Starting Clusters, Monitoring, and Debugging</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#in-this-tutorial-you-will-learn">In this tutorial, you will learn:</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#starting-hpc-dask-clusters-with-dask-jobqueue">Starting HPC Dask clusters with <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-scheduled-cluster">Creating a scheduled-cluster</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#it-is-good-practice-to-check-your-validate-your-cluster-before-initiating-any-workers-by-outputting-the-job-script-dask-will-create">It is good practice to check your validate your cluster before initiating any workers, by outputting the job script Dask will create</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dask-configuration-files">Dask configuration files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#live-performance-monitoring">Live Performance Monitoring</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dashboard-demo-multi-file-xarray-data-analysis">Dashboard demo: multi-file Xarray data analysis</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#aside-clusters-can-also-adaptively-scale">Aside: Clusters can also adaptively scale</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#optimization-persisting-data-in-worker-memory">Optimization: Persisting data in worker memory</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#debugging-workers-case-study-memory-and-spill-to-disk">Debugging workers case study: memory and spill-to-disk</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analyzing-your-allocation">Analyzing your allocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#additional-considerations">Additional Considerations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dask-worker-count">Dask Worker Count</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-dask-on-gpus">Using Dask on GPUs</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <p><img src="https://raw.githubusercontent.com/NCAR/dask-tutorial/main/images/NCAR-contemp-logo-blue.png"
     width="750px"
     alt="NCAR logo"
     style="vertical-align:middle;margin:30px 0px"/></p>
<section class="tex2jax_ignore mathjax_ignore" id="dask-on-hpc-starting-clusters-monitoring-and-debugging">
<h1>Dask on HPC - Starting Clusters, Monitoring, and Debugging<a class="headerlink" href="#dask-on-hpc-starting-clusters-monitoring-and-debugging" title="Permalink to this heading">#</a></h1>
<p><strong>ESDS Dask tutorial | 06 February, 2023</strong></p>
<p>Negin Sobhani, Brian Vanderwende, Deepak Cherian, Ben Kirk<br />
Computational &amp; Information Systems Lab (CISL)<br />
<a class="reference external" href="mailto:negins&#37;&#52;&#48;ucar&#46;edu">negins<span>&#64;</span>ucar<span>&#46;</span>edu</a>, <a class="reference external" href="mailto:vanderwb&#37;&#52;&#48;ucar&#46;edu">vanderwb<span>&#64;</span>ucar<span>&#46;</span>edu</a></p>
<hr class="docutils" />
<section id="in-this-tutorial-you-will-learn">
<h2>In this tutorial, you will learn:<a class="headerlink" href="#in-this-tutorial-you-will-learn" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>How to configure and initialize an HPC Dask cluster via <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code></p></li>
<li><p>How to manage and monitor the resource usage of your Dask workers</p></li>
<li><p>Understanding Dask worker logs</p></li>
<li><p>Controlling how and where data spills from memory to disk</p></li>
<li><p>Analyzing the impact of your Dask workflow on your allocation</p></li>
</ul>
<p><strong>Related Documentation</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://jobqueue.dask.org/en/latest/">dask-jobqueue documentation</a></p></li>
<li><p><a class="reference external" href="https://distributed.dask.org/en/stable/diagnosing-performance.html">Diagnosing Distributed Dask Performance</a></p></li>
<li><p><a class="reference external" href="https://jobqueue.dask.org/en/latest/configurations.html">Dask HPC Configuratio Examples</a></p></li>
<li><p><a class="reference external" href="https://arc.ucar.edu/knowledge_base/70549817">Managing HPC allocations at NCAR</a></p></li>
</ul>
</section>
<hr class="docutils" />
<section id="starting-hpc-dask-clusters-with-dask-jobqueue">
<h2>Starting HPC Dask clusters with <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code><a class="headerlink" href="#starting-hpc-dask-clusters-with-dask-jobqueue" title="Permalink to this heading">#</a></h2>
<p>A defining feature of most HPC systems is the batch scheduler - <em>Slurm, PBS, LSF, etc…</em> These schedulers allow us to access the significant resources of the system and scale far beyond what is capable by a personal workstation.</p>
<p>Using Dask on an HPC system is no different - we need to interact with the scheduler to provide Dask with ample compute resources. We <em>could</em> first start a job with multiple cores and a large amount of memory, and then use the <strong>LocalCluster</strong> to spawn workers. However, this approach only scales to a single node.</p>
<p>The typical approach is to let Dask request resources directly from the job scheduler via a scheduler-specific cluster type. Such clusters are provided by the add-on <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code> package.</p>
<section id="creating-a-scheduled-cluster">
<h3>Creating a scheduled-cluster<a class="headerlink" href="#creating-a-scheduled-cluster" title="Permalink to this heading">#</a></h3>
<p>Since we use the PBS Pro scheduler at NCAR, we will use the <strong>PBSCluster</strong> Dask scheduler from <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code>. Initialization is similar to a <strong>LocalCluster</strong>, but with unique parameters specific to creating batch jobs.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">from</span> <span class="nn">dask_jobqueue</span> <span class="kn">import</span> <span class="n">PBSCluster</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>
</pre></div>
</div>
</div>
</div>
<p>The parameters of the <code class="docutils literal notranslate"><span class="pre">PBSCluster</span></code> provide a basic template for the resources that will be assigned to each job…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a PBS cluster object</span>
<span class="n">cluster</span> <span class="o">=</span> <span class="n">PBSCluster</span><span class="p">(</span>
    <span class="n">job_name</span> <span class="o">=</span> <span class="s1">&#39;dask-wk23-hpc&#39;</span><span class="p">,</span>
    <span class="n">cores</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">memory</span> <span class="o">=</span> <span class="s1">&#39;4GiB&#39;</span><span class="p">,</span>
    <span class="n">processes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">local_directory</span> <span class="o">=</span> <span class="s1">&#39;/local_scratch/pbs.$PBS_JOBID/dask/spill&#39;</span><span class="p">,</span>
    <span class="n">resource_spec</span> <span class="o">=</span> <span class="s1">&#39;select=1:ncpus=1:mem=4GB&#39;</span><span class="p">,</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="s1">&#39;casper&#39;</span><span class="p">,</span>
    <span class="n">walltime</span> <span class="o">=</span> <span class="s1">&#39;30:00&#39;</span><span class="p">,</span>
    <span class="n">interface</span> <span class="o">=</span> <span class="s1">&#39;ext&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><em>Since we are working on a shared system, you may get a port-in-use warning. This is no cause for alarm, but make sure you are not starting a duplicate cluster unintentionally.</em></p>
<p>We should pause and consider some of these settings…</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">cores</span></code> and <code class="docutils literal notranslate"><span class="pre">memory</span></code> parameters are used by Dask to define workers, while the <code class="docutils literal notranslate"><span class="pre">resource_spec</span></code> is used by PBS to define jobs. In this single-worker config, they should match!</p></li>
<li><p>PBS uses <em>GB</em> to mean 1024-based storage units. <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code> accurately calls these <code class="docutils literal notranslate"><span class="pre">GiB</span></code>.</p></li>
<li><p>We use <code class="docutils literal notranslate"><span class="pre">interface='ext'</span></code> to instruct Dask to use TCP over the high-speed ethernet instead of other, slower, ethernet devices.</p></li>
</ul>
<p>Note also that we are using one worker per PBS job. This is a reasonable default on Casper, but it is possible to group workers together on one or more PBS jobs as well by increasing the <code class="docutils literal notranslate"><span class="pre">cores</span></code> and <code class="docutils literal notranslate"><span class="pre">ncpus</span></code>. Here are some considerations:</p>
<p><strong>Using less workers per job will:</strong></p>
<ul class="simple">
<li><p>Increase job throughput on most systems (easier to backfill smaller jobs)</p></li>
<li><p>Will always avoid interpretor lock issues</p></li>
<li><p>Is conceptually easy to understand</p></li>
<li><p>May be more robust if system is unstable</p></li>
<li><p>Can speed up file-reads in some situations</p></li>
</ul>
<p><strong>Using more workers per job will:</strong></p>
<ul class="simple">
<li><p>Less overhead in thread-friendly workflows</p></li>
<li><p>May allow for slightly higher memory thresholds since they will share a pool</p></li>
</ul>
<section id="it-is-good-practice-to-check-your-validate-your-cluster-before-initiating-any-workers-by-outputting-the-job-script-dask-will-create">
<h4>It is good practice to check your validate your cluster before initiating any workers, by outputting the job script Dask will create<a class="headerlink" href="#it-is-good-practice-to-check-your-validate-your-cluster-before-initiating-any-workers-by-outputting-the-job-script-dask-will-create" title="Permalink to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">cluster</span><span class="o">.</span><span class="n">job_script</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p><em>Note how some settings are showing up despite me not setting them… where does my account come from, for example?</em></p>
<p>Let’s take a detour for a moment…</p>
</section>
</section>
<section id="dask-configuration-files">
<h3>Dask configuration files<a class="headerlink" href="#dask-configuration-files" title="Permalink to this heading">#</a></h3>
<p>We can customize the behavior of Dask using YAML-based configuration files. These have some advantages:</p>
<ul class="simple">
<li><p>Eliminate user-specific configuration from your notebooks/scripts</p></li>
<li><p>Avoid repetition in defining clusters and other Dask objects</p></li>
<li><p>Potentially reduce errors from forgetting important settings</p></li>
</ul>
<p>And also some downsides:</p>
<ul class="simple">
<li><p>Obfuscates settings from others (including your future self!)</p></li>
<li><p>Reduces portability and ease of debugging</p></li>
</ul>
<p>User configuration files are stored in <code class="docutils literal notranslate"><span class="pre">~/.config/dask</span></code> by default. System administrators may also provide default Dask configuration in <code class="docutils literal notranslate"><span class="pre">/etc/dask</span></code> or via the <code class="docutils literal notranslate"><span class="pre">DASK_ROOT_CONFIG</span></code> environment variable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>ls<span class="w"> </span>~/.config/dask
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Programmatically view configuration file(s) within Python</span>
<span class="kn">from</span> <span class="nn">dask</span> <span class="kn">import</span> <span class="n">config</span>
<span class="n">config</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jobqueue.pbs&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="live-performance-monitoring">
<h3>Live Performance Monitoring<a class="headerlink" href="#live-performance-monitoring" title="Permalink to this heading">#</a></h3>
<p>Using <code class="docutils literal notranslate"><span class="pre">dask.distributed</span></code> provides us with a powerful diagnostic tool you have already seen: the <em>Dashboard</em>. The Dashboard can be integrated into your Jupyter environment in two ways - either with a separate website accessible from the Client widget, or as tabs in your JupyterLab interface via the <code class="docutils literal notranslate"><span class="pre">dask-labextension</span></code> add-on.</p>
<p><strong>Tip:</strong> JupyterLab Dashboard tabs can be saved as a “workspace” and loaded back in future sessions.</p>
<p>Let’s see how both can be used to monitor Dask workers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the client to load the Dashboard</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Display the client repr</span>
<span class="n">client</span>
</pre></div>
</div>
</div>
</div>
<p>The Dashboard is immediately accessible above when using NCAR’s JupyterHub. This URL can also be entered into the Dashboard extension (click the Dask logo on the left toolbar), which allows you to add useful screens like <code class="docutils literal notranslate"><span class="pre">Task</span> <span class="pre">Stream</span></code> and <code class="docutils literal notranslate"><span class="pre">Workers</span> <span class="pre">Memory</span></code> to your Lab interface.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Scale the cluster to 2 workers (which will use 2 jobs here)</span>
<span class="n">cluster</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Block progress until workers have spawned (typically only in demos and benchmarks!)</span>
<span class="n">client</span><span class="o">.</span><span class="n">wait_for_workers</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># See the workers from the cluster object</span>
<span class="n">cluster</span><span class="o">.</span><span class="n">workers</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># See the workers in the job scheduler</span>
<span class="o">!</span>qstat<span class="w"> </span>-u<span class="w"> </span><span class="nv">$USER</span>
</pre></div>
</div>
</div>
</div>
<p><em>As soon as we scale the cluster up, the clock is ticking on these PBS jobs. Be mindful of idle workers when using a batch scheduler!</em></p>
<section id="dashboard-demo-multi-file-xarray-data-analysis">
<h4>Dashboard demo: multi-file Xarray data analysis<a class="headerlink" href="#dashboard-demo-multi-file-xarray-data-analysis" title="Permalink to this heading">#</a></h4>
<p>To demonstrate how the Dashboard can be useful, let’s do some simple analysis of data files using Xarray. Here we load 19 days of GOES5 data, and compute the mean near-surface temperature across the western US.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use a multi-file import and load data in parallel</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_mfdataset</span><span class="p">(</span><span class="s2">&quot;/glade/collections/rda/data/ds313.0/orig_res/2022/GEOS5_orig_res_202201[0-1]*.nc&quot;</span><span class="p">,</span> <span class="n">parallel</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Show the total size of the variable (this has not been read in yet!)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size of Variable = </span><span class="si">{:5.2f}</span><span class="s2"> GiB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>This data is much too big for our worker template, but as we have seen the chunks will be smaller in size. We can see if they will fit in RAM or cause spill by querying the data array</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The graphical repr of one DaskArray - T</span>
<span class="n">ds</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<p>It looks like our data chunks will fit into RAM, but we can verify using the Dashboard. Let’s construct our computation. Here we do the following:</p>
<ol class="arabic simple">
<li><p>Subset the “western US” from the data via lat/lon slices</p></li>
<li><p>Take the mean of temperature values across our western US box</p></li>
<li><p>Select the near-surface level (0)</p></li>
</ol>
<p>Remember, we are just creating the task graph here. No work will occur yet in our cluster.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create our task graph</span>
<span class="n">sfc_mean_graph</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">235</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tip - double-click the figure to see the actual size</span>
<span class="n">dask</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">sfc_mean_graph</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we can use <code class="docutils literal notranslate"><span class="pre">.compute()</span></code> to start the computation on our cluster. Keep an eye on the dashboard plots to follow progress.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sfc_mean_graph</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now, let’s see what speedup we can get by manually scaling up our computation by 2x. This is not possible (<em>beyond a certain hardware limit</em>) on a <code class="docutils literal notranslate"><span class="pre">LocalCluster</span></code>, but is easy to do using <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code>!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Scale the cluster to 4 workers</span>
<span class="n">cluster</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">client</span><span class="o">.</span><span class="n">wait_for_workers</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># How does this look in PBS?</span>
<span class="o">!</span>qstat<span class="w"> </span>-u<span class="w"> </span>vanderwb
</pre></div>
</div>
</div>
</div>
<p>One downside of scaling is that you end up with a worker pool that has different amounts of wallclock time remaining. The flow of your script across time is something to consider - if you need to spin up more workers after some collection of them has used significant walltime, it may make sense to first scale down your cluster to zero (or run <code class="docutils literal notranslate"><span class="pre">client.restart()</span></code>) and then instantiate the new workers.</p>
<p>Here, we will also demonstrate another type of performance monitoring provided by <code class="docutils literal notranslate"><span class="pre">dask.distributed</span></code> - the <em>performance report</em>. Using a context manager, we can profile the computational components in the task stream and store it as an HTML file for future analysis. It provides a hard copy analysis of the computation, though unfortunately it does not record worker memory usage.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s try generating a &quot;performance report&quot; this time</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">performance_report</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="c1"># Since metrics are captured live anyway, the overhead from the report is small</span>
<span class="k">with</span> <span class="n">performance_report</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;dask-report.html&quot;</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">sfc_mean_graph</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Hopefully, we see a significant improvement in time-to-solution using 2x the workers.</p>
<p>Another improvement we can make to our computation is to reduce the size of the problem down as much as possible before doing meaningful work. Let’s try rearranging our graph:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create our improved task graph</span>
<span class="n">sfc_mean_graph</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">235</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sfc_mean_graph</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Since flattening the level dimension will reduce data compared to the lat-lon box, let’s do that first to make subsequent operations cheaper.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Indexing</p></th>
<th class="head"><p>Dimensions</p></th>
<th class="head"><p>Pts Eliminated</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>isel</p></td>
<td><p>721 x 1152 x 71</p></td>
<td><p>58,972,032</p></td>
</tr>
<tr class="row-odd"><td><p>sel</p></td>
<td><p>(721 - 81) x (1152 - 81) x 72</p></td>
<td><p>49,351,680</p></td>
</tr>
</tbody>
</table>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Can we do better?</span>
<span class="n">sfc_mean_graph</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">235</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sfc_mean_graph</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In this case, optimizations to the base operation can yield better speed improvements than doubling the dask worker count. <strong>Optimize your workflow first, if possible - then parallelize with Dask if still necessary.</strong></p>
<p>Let’s plot our results again to inspect for differences.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="aside-clusters-can-also-adaptively-scale">
<h4>Aside: Clusters can also adaptively scale<a class="headerlink" href="#aside-clusters-can-also-adaptively-scale" title="Permalink to this heading">#</a></h4>
<p>For interactive, exploratory work, <em><a class="reference external" href="https://docs.dask.org/en/stable/how-to/adaptive.html">adaptive scaling</a></em> can be useful (also very useful on cloud platforms). This allows the cluster to dynamically scale up and down based on the (Dask) scheduler’s estimation of resource needs. This capability is highly customizable, but one basic method would be to set bounds on the number of worker jobs that can be used:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cluster</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">minimum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">maximum</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
<p>Another benefit of adaptive scaling is that you can use the worker <code class="docutils literal notranslate"><span class="pre">--lifetime</span></code> argument to tell Dask to cleanly end work on a worker and restart the PBS job. If you stagger the start of your workers, Dask will be able to shuffle tasks appropriately to produce a so-called <em><a class="reference external" href="https://jobqueue.dask.org/en/latest/advanced-tips-and-tricks.html#how-to-handle-job-queueing-system-walltime-killing-workers">infinite workload</a></em>.</p>
<p>On busy systems, adaptive scaling can slow down bursty computations because of queue waits between scale-down and scale-up cycles.</p>
</section>
<section id="optimization-persisting-data-in-worker-memory">
<h4>Optimization: Persisting data in worker memory<a class="headerlink" href="#optimization-persisting-data-in-worker-memory" title="Permalink to this heading">#</a></h4>
<p>Sometimes you will need to compute multiple parameters on data from Dask objects. Using <code class="docutils literal notranslate"><span class="pre">.persist()</span></code> to store intermediate data in worker memory can save computational time if used appropriately. The raw data can be persisted too, of course, but watch out for exhausting worker memory.</p>
<p>Here we compare the time it takes - with and without persisting intermediate results - to compute our level-0 mean, a level-10 mean, and a mean across all model levels.</p>
<p>We will also introduce another diagnostic tool here, the <code class="docutils literal notranslate"><span class="pre">MemorySampler</span></code> context manager.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distributed.diagnostics</span> <span class="kn">import</span> <span class="n">MemorySampler</span>
<span class="n">ms</span> <span class="o">=</span> <span class="n">MemorySampler</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="c1"># Without persistance</span>
<span class="k">with</span> <span class="n">ms</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;Original&quot;</span><span class="p">):</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">235</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">235</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">235</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="s2">&quot;lev&quot;</span><span class="p">,</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="c1"># With persistance</span>
<span class="k">with</span> <span class="n">ms</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;Persist&quot;</span><span class="p">):</span>
    <span class="n">T_means</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">235</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">lat</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span><span class="s2">&quot;lon&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">T_means</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">T_means</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">lev</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
    <span class="n">ra</span> <span class="o">=</span> <span class="n">T_means</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s2">&quot;lev&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Without persisting the intermediate results, Dask will only store r1 and r2 in worker memory, and so the indexing operations must be done from scratch each time.</p>
<p>Let’s look at the memory usage…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ms</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">align</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Because the intermediate results are required for the second calculation in the original case, we do not even use more memory. A clear win!</p>
<p>Of course, when persisting data it is extra important to clean up. Running <code class="docutils literal notranslate"><span class="pre">del</span></code> on your persisted client variable will clear those data from worker memory (<em>as long as they are not referenced by other variables</em>). The <strong>progress</strong> dashboard is a useful reminder that we have data persisted.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">T_means</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Close current workers</span>
<span class="n">cluster</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="debugging-workers-case-study-memory-and-spill-to-disk">
<h3>Debugging workers case study: memory and spill-to-disk<a class="headerlink" href="#debugging-workers-case-study-memory-and-spill-to-disk" title="Permalink to this heading">#</a></h3>
<p>In this section, we will demonstrate two common considerations when using Dask on HPC:</p>
<ul class="simple">
<li><p>Dask data spilling to disk</p></li>
<li><p>Interacting with <code class="docutils literal notranslate"><span class="pre">dask.distributed</span></code> worker logs</p></li>
</ul>
<p>For this case study, we will generate progressively larger Dask arrays that eventually trigger memory conditions. Dask workers handle data in different ways in the following memory regimes:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Suggested Threshold</p></th>
<th class="head"><p>Case Study Value</p></th>
<th class="head"><p>Worker Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0.6 (managed mem)</p></td>
<td><p>2.4 GB</p></td>
<td><p>Data is allocated on disk (spill)</p></td>
</tr>
<tr class="row-odd"><td><p>0.7 (process mem)</p></td>
<td><p>2.8 GB</p></td>
<td><p>Data is allocated on disk (spill)</p></td>
</tr>
<tr class="row-even"><td><p>0.8</p></td>
<td><p>3.2 GB</p></td>
<td><p>New data allocation is paused</p></td>
</tr>
<tr class="row-odd"><td><p>0.95</p></td>
<td><p>3.8 GB</p></td>
<td><p>Worker is killed to avoid OOM</p></td>
</tr>
</tbody>
</table>
<p>These thresholds can be set at cluster creation time or overridden by your Dask Distributed configuration file.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="kn">from</span> <span class="nn">distributed.worker</span> <span class="kn">import</span> <span class="n">logger</span>
</pre></div>
</div>
</div>
</div>
<p>It is possible to write directly to worker logs (PBS job logs in our case) using the worker <code class="docutils literal notranslate"><span class="pre">logger</span></code> from Dask Distributed. Here, we define a function to call the logger on each worker, which we will run eagerly via <code class="docutils literal notranslate"><span class="pre">client.run</span></code>.</p>
<p>Keep an eye on the worker memory Dashboard panel as our for loop proceeds…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">log_message</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Current chunk size = </span><span class="si">{}</span><span class="s2"> MiB&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Start up 4 new workers</span>
<span class="n">cluster</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">client</span><span class="o">.</span><span class="n">wait_for_workers</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">chunk_mib</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1600</span><span class="p">,</span> <span class="mi">2400</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">3900</span><span class="p">]:</span>
    <span class="n">client</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">log_message</span><span class="p">,</span> <span class="n">chunk_mib</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk_mib</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mean of </span><span class="si">{}</span><span class="s2"> MiB random array = </span><span class="si">{:0.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chunk_mib</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">chunk_size</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">compute</span><span class="p">()))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># List the most recent 4 worker logs - these should be our logs</span>
<span class="o">!</span>ls<span class="w"> </span>-lrt<span class="w"> </span>dask-worker-logs<span class="w"> </span><span class="p">|</span><span class="w"> </span>tail<span class="w"> </span>-n<span class="w"> </span><span class="m">4</span>
</pre></div>
</div>
</div>
</div>
<p>We can open the log file in the Lab interface or a terminal and investigate the reason for the <code class="docutils literal notranslate"><span class="pre">KilledWorker</span></code> exception.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s look at the worker state in PBS after the failure</span>
<span class="o">!</span>qstat<span class="w"> </span>-u<span class="w"> </span>vanderwb
</pre></div>
</div>
</div>
</div>
<p>Notice how the workers retried the final computation a few times before giving up. This behavior occurs when using the <code class="docutils literal notranslate"><span class="pre">nanny</span></code>, which attempts to restore workers when they are killed for various exceptions. (<em>the nanny is an additional lightweight process that monitors the health of the worker and enables functionality like full cluster restart</em>)</p>
<p>Recall the aforementined memory thresholds - workers get killed by Dask before exceeding the absolute limit of a job (which if hit on certain systems, could kill the PBS job too). Because of this safety mechanism, our PBS jobs are still intact.</p>
<p>If you are running a long computation that, <em>if restarted</em>, could exhaust the worker job’s walltime, you can disable the nanny functionality and make exceptions fatal.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Shut down our client (thus terminating workers)</span>
<span class="n">client</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="analyzing-your-allocation">
<h2>Analyzing your allocation<a class="headerlink" href="#analyzing-your-allocation" title="Permalink to this heading">#</a></h2>
<p>Dask does not provide integrated tools for analyzing the impact to your allocation (though you could back out values with care). This job is best suited for the scheduler itself, assuming that you’ve carefully instantiated your workers.</p>
<p>Consider this value from our cluster config:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cluster</span><span class="o">.</span><span class="n">job_name</span>
</pre></div>
</div>
</div>
</div>
<p>This means that every Dask worker I start via this workflow’s <code class="docutils literal notranslate"><span class="pre">PBSCluster</span></code> will have the job name <strong>dask-wk23-hpc</strong>. We can leverage this along with our <code class="docutils literal notranslate"><span class="pre">qhist</span></code> utility to query the logs:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>qhist<span class="w"> </span>-u<span class="w"> </span><span class="nv">$USER</span><span class="w"> </span>-N<span class="w"> </span>dask-wk23-hpc<span class="w"> </span>-f<span class="w"> </span>numcpus,elapsed<span class="w"> </span>-c<span class="w"> </span>&gt;<span class="w"> </span>qhist-dask.out
</pre></div>
</div>
<p>This command will query all dask-workers in today’s scheduler logs and output to CSV, which we redirect to a file. The <code class="docutils literal notranslate"><span class="pre">name</span></code> field is a powerful tool. If instead you use a worker name specific to your script, you can easily query only the jobs from that script. <em>Confusingly, if you wish to set the job name when creating your cluster object, use the <code class="docutils literal notranslate"><span class="pre">job_name</span></code> parameter, not <code class="docutils literal notranslate"><span class="pre">name</span></code>!</em></p>
<p>We can then read in the CSV using pandas (or even using a Dask Dataframe!).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dj</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../data/qhist-dask.out&quot;</span><span class="p">)</span>
<span class="n">dj</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Core-hours used by this notebook: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dj</span><span class="p">[</span><span class="s1">&#39;NCPUs&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">dj</span><span class="p">[</span><span class="s1">&#39;Elapsed (h)&#39;</span><span class="p">])))</span>
</pre></div>
</div>
</div>
</div>
<p>Records from <code class="docutils literal notranslate"><span class="pre">qhist</span></code> span the time that PBS was used on each system, so with a bit of forward-thinking prep work (picking descriptive worker names), you can easily trace back usage.</p>
</section>
<section id="additional-considerations">
<h2>Additional Considerations<a class="headerlink" href="#additional-considerations" title="Permalink to this heading">#</a></h2>
<p>As we’ve shown, Dask is flexible and highly configurable. While we will not cover the following topics in depth, we encourage you to explore further on your own (and let us know in the <em>survey</em> if you would like learn more!).</p>
<section id="dask-worker-count">
<h3>Dask Worker Count<a class="headerlink" href="#dask-worker-count" title="Permalink to this heading">#</a></h3>
<p>You may be wondering how to choose the number of workers. This question is tricky and can often depend on the state of the machine at any time. Here are some absolutes:</p>
<ol class="arabic simple">
<li><p>Use more than a single worker unless debugging or profiling</p></li>
<li><p>Do not use more workers than you have chunks - they will be idle</p></li>
</ol>
<p>And here are some guidelines:</p>
<ol class="arabic simple">
<li><p>If you have to choose between more workers vs. more memory per worker, let the chunk size be your guide (more on this in the next notebook)</p></li>
<li><p>In general, requesting less workers with more memory will take longer to get through the queue than more workers with less memory; <em>typically memory is more constrained than CPU cores on analysis machines</em></p></li>
<li><p>Using <a class="reference external" href="https://docs.dask.org/en/stable/how-to/adaptive.html"><strong>adaptive scaling</strong></a> will make your workflow throughput less senstive to the state of the HPC jobs queue</p></li>
</ol>
</section>
<section id="using-dask-on-gpus">
<h3>Using Dask on GPUs<a class="headerlink" href="#using-dask-on-gpus" title="Permalink to this heading">#</a></h3>
<p>Much like Xarray can use NumPy arrays or Dask arrays, Dask itself can use NumPy arrays or <a class="reference external" href="https://cupy.dev/">CuPy</a> arrays - the latter of which are GPU enabled on both NVIDIA and AMD hardware. For NVIDIA users, the <a class="reference external" href="https://rapids.ai/">RAPIDS</a> suite offers cuDF - a drop in replacement for pandas DataFrames which can also be used with Dask. And efforts are underway to effectively use GPUs with Xarray and Dask.</p>
<p>For a starting point, check out the <a class="reference external" href="https://www2.cisl.ucar.edu/events/gpu-series-multiple-gpus-python-dask">Dask with GPUs</a> tutorial CISL offered in Summer 2022.</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "npl-2023a"
        },
        kernelOptions: {
            name: "npl-2023a",
            path: "./notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'npl-2023a'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="04-dask-cluster.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Dask Schedulers</p>
      </div>
    </a>
    <a class="right-next"
       href="06-dask-chunking.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Dask Chunking - Best Practices</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#in-this-tutorial-you-will-learn">In this tutorial, you will learn:</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#starting-hpc-dask-clusters-with-dask-jobqueue">Starting HPC Dask clusters with <code class="docutils literal notranslate"><span class="pre">dask-jobqueue</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-scheduled-cluster">Creating a scheduled-cluster</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#it-is-good-practice-to-check-your-validate-your-cluster-before-initiating-any-workers-by-outputting-the-job-script-dask-will-create">It is good practice to check your validate your cluster before initiating any workers, by outputting the job script Dask will create</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dask-configuration-files">Dask configuration files</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#live-performance-monitoring">Live Performance Monitoring</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dashboard-demo-multi-file-xarray-data-analysis">Dashboard demo: multi-file Xarray data analysis</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#aside-clusters-can-also-adaptively-scale">Aside: Clusters can also adaptively scale</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#optimization-persisting-data-in-worker-memory">Optimization: Persisting data in worker memory</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#debugging-workers-case-study-memory-and-spill-to-disk">Debugging workers case study: memory and spill-to-disk</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analyzing-your-allocation">Analyzing your allocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#additional-considerations">Additional Considerations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dask-worker-count">Dask Worker Count</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-dask-on-gpus">Using Dask on GPUs</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Negin Sobhani, Brian Vanderwende, Deepak Cherian, Ben Kirk
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>